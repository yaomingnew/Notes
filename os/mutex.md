# 同步互斥

## 同步互斥的背景

### 独立进程

- 不和其他进程共享资源和状态
- 确定性：输入状态决定结果
- 可重现：能够重现结果
- 调度顺序不重要

### 并发进程

- 多个进程之间有资源共享
- 不可确定
- 不可重现

### 进程并发执行的好处

- 进程需要与计算机中其他的进程和设备进行协作
- 好处1：共享资源，完成更加复杂的任务
- 好处2：提高速度，占用不同资源的进程可以同时运行
- 好处3：模块化

### 原子操作

- 是指一次不存在任何中断或失败的操作
  - 即要么成功执行，或者操作没有执行，不会出现部分执行的情况
  - 操作系统需要利用同步机制在并发执行的同时，能够保证一些操作是原子操作

## 临界区（critical section）

### 临界区的结构

- 临界区：进程中访问临界资源的一段需要互斥执行的代码
- 进入区：检查是否可以进入临界区的一段代码，如果可以进入，设置一个“正在访问临界区”标志位
- 退出区：清除“正在访问临界区”标志位
- 剩余区

### 临界区的访问规则

- 空闲则入
- 忙则等待
- 有限等待
- 让权等待（可选）

### 临界区访问的实现方法

#### 禁用中断

- 没有中断，没有上下文切换，因此也没有并发，相当于一个独占的进程
##### 禁用中断的缺点
  - 禁用中断之后，整个系统都会为此停下来，进程也无法被停止
  - 同时会导致其他的进程处于饥饿的状态
  - 临界区很长的情况下，会导致中断无法被及时响应的问题

#### 软件方法

- 设置一个变量turn，turn变量用来代表进程Ti是否可以（可观条件是否允许）进入临界区执行临界区的代码

- 设置一个flag位，来表示进程Ti自己是否想要（主观上进程自己是否想要）进入临界区

  ![try 1, 只有turn位](./pics/try_1.jpg)

  - 这种方法由对方的进程来将turn这个变量进行调整，所以假设1进程刚刚从临界区出来，将turn设置位2，但是进程2不需要进入临界区，而此时进程1又要再次进入临界区。那么此时，两个进程都无法通过进入区的判断条件，从而无法进入临界去区

  ![try 2, 只有flag位](./pics/try_2.jpg)

  - 这中方法为每一个进程设置了flag位，若flag位为1，则说明该进程正在临界区中执行操作。这个方法的问题是在起始阶段，flag[1] == 0，flag[2] == 0，两个进程在前后分别进入while循环进行判断。此时，两个进程都可以进入临界区，从而使得互斥目标失败

  ![try 3,将设置flag位的时机放到while判断条件的前面](./pics/try_3.jpg)

  - 第三个方法将设置flag位的时机放到while判断条件的前面，企图尝试避免“第二种尝试”的时候，进程1，进程2都会先后进入临界区的情况。但是，依然考虑进程1，2在同一时刻前后运行的这种情况，这种方法又会导致两个进程都无法满足判断的条件（被卡在各自进程的while循环中无法跳出），一直在临界区外卡住

  ![peterson algorithm](./pics/peterson_algorithm.jpg)

  - Peterson 算法成功实现了两个进程互斥访问同一临界资源区的难题，那么这一算法到底是怎么做的呢？

    - 首先每个进程会有自己的flag位，这个flag位表示的是本进程是否需要进入临界区运行，即我这个进程在当前是否有进入临界区运行的愿望

    - 除此之外，两个进程还会有一个共享的变量turn，turn表示的是谁能够进入临界区

    - flag强调的是进程自己主观的愿望，而turn强调的是当前的客观条件能否让某一进程进入，而两个进程都会主动“谦让”，将turn这个变量设置成“对方可入”的状态

    - while循环里面的条件此时可以这样解读：对于进程1来说

      ```
      如果进程1想要进入临界区
      flag[1] = TRUE; // 进程1想要进入临界区
      turn = 2;	    // 本着谦让的原则，进程1先请进程2来进入临界区
      while (flag[2] == TRUE && turn == 2); // 如果进程2想要进入，且现在的客观情况就是轮到进程									// 2，则进程1就会等待
      								   // 如果flag[2] == FALSE，进程2不想进入临界区
      								   // 或者turn == 1，现在不该进程2进入临界区
      	ENTER CRITICAL SECTION
      flag[1] = FALSE; // 改变flag的状态，表示现在没有进入临界区的愿望
      	REMAINDER SECTION
      ```

##### 软件方法的缺点

  - 复杂，设置的变量很多
  - 需要忙等待，浪费CPU的资源

#### 更高级的抽象方法